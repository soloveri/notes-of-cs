---
title: java的内存布局
mathjax: true
data: 2020-07-21 23:32:14
updated:
tags: 内存布局
categories: jvm
---

## 前言

众所周知,java虚拟机的内存布局和传统的内存布局都差不多,都分为栈、堆啥的。准确的来说，jvm的内存分为以下几个部分:

- 程序计数器(就是eip)
- 堆
- 方法区
- 本地方法栈
- 虚拟机栈

其中堆和方法区是所有线程锁共享的,而程序计数器、栈肯定都是线程私有的,因为这与程序的正常运行息息相关。

上述的五个区域都可能产生内存溢出,有的还可能产生内存泄漏(虽然内存由jvm管理,但是并不能保证内存不会泄露奥)。下面我将一一介绍上述四个区域(不包括程序计数器)产生内存溢出的一般情况,当然大部分内容还是来自<<深入理解JVM>>一书,我在这里仅仅做个概括加上自己一点的感想。

## 0x1 虚拟机栈

虚拟机栈跟传统汇编里的栈感觉差不多,只不过这里用所谓的局部变量槽来保存(Slot)。当然栈就是用来存储局部变量和返回地址的，内容肯定和传统栈一样。当然本地方法栈和虚拟机栈在性质上就是一类东西,**仅仅是用途不同而已**。所以就不单独分开说本地方法栈了。

Tips:
> 当进入一个方法时,这个方法需要多少个局部变量槽是确定的,局部变量所需的内存在编译时期分配完成,而具体内存是多少个byte是不确定的,因为局部变量槽的实现方式不在JVM规范中。由虚拟机厂商所决定。

上面这个我也是才注意的,不像传统栈可以不停的push,使用的大小完全无法确定。

进入正题,虚拟机栈可能会发生两种内存错误:

- StackOverFlow
- OutOfMemeory

StackOverFlow要么是死递归造成的栈空间不够,要么是局部变量太多。感觉后者不太可能发生,因为需要的局部变量太多儿。所以出现StackOverFlow的第一直觉就是死递归。

第二种出现于允许栈可扩展的虚拟机中。虚拟机之王HotSpot是不支持虚拟机栈扩展的。但是仍然可能出现OOM,当线程申请栈空间失败时。反之申请成功就永远不会出现OOM。


## 0x2 堆

### 0x2-1 方法区

### 0x2-2 运行时常量池

## 0x3 直接内存