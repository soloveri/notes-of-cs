---
title: 类的加载步骤
mathjax: true
data: 2020-11-05 21:16:52
updated:
tags: 类加载
categories: jvm
---

## 1. 类加载的七步

将类的Class文件加载至jvm中一般会经历七个步骤：加载、验证、准备、解析、初始化、使用、卸载。但是注意：**这七个步骤并不是完全串行的**。有可能在一个步骤的执行中开启另外一个步骤，而不是等待当前步骤执行完毕。

并且其中的验证、准备、解析合在一起叫做“连接”。这不就是cpp编译过程的符号链接的步骤嘛，搞的这么花里胡哨的。

并且其中的初始化是指类的初始化，而不是对象的初始化。类的初始化是指：

- 静态字段的初始化
- 静态代码的执行

并且类的初始化只会在类加载的时候执行一次。下面我们就来看看这七个步骤。

## 2. 加载

这个加载是指整个类加载过程中的第一个步骤，而且是整个类加载过程中我们可以实实在在用代码控制的部分。该步骤分为三小步：

1. 通过类的全限定名获取类的二进制字节流
2. 将二进制字节流表示的静态存储结构转化**方法区**为运行时存储结构
3. 生成Class对象，作为方法区各种类型数据的访问接口

其中通过类的权限名获取类的二进制字节流就是我们能够控制的部分，虚拟机规范只规定了我们要获取字节流，而没有规定从哪里获取字节流。可以从Class文件中获取、静态的jar包中获取、网络中获取，或者动态的在内存中生成，也就是所谓的动态代理技术，这完全都可以自定义实现。**并且获取字节流这个动作就是通过我们自定义的类加载器来实现。**

但是有一个特殊情况，就是数组类的加载不是我们可以控制的，但是数组中的元素类却又是我们可以控制的。因为**数组类的并不是由类加载器加载，而是由jvm在内存中直接构造的。**

---
这里的数组类可以看作数组的wrapper，即数组的包装类，由jvm动态生成，数组类提供了一些数组的属性，并且数组的访问也通过该类实现。

>java访问数组的安全性比c++高很大程度是因为该类包装了数组的访问操作。
---

### 2.1 数组类的加载机制

- 如果数组的组件类型(即数组去掉一个维度，例如int[4]\[3],实际的组件类型为int[3],因为二维数组可以看作元素类型是一维数组的一维数组)。那么就递归的采用类加载过程去加载这个组件类型。是类就用类的加载过程，是数组类就用数组类的加载过程。并且该数组会被标识在加载该组件类型的类加载器的类名称空间上，因为这样才能唯一的确定一个类
- 如果数组的组件类型不是引用类型，那么该数组会被标识在启动类加载器的类名称空间上
- 数组类的可访问性和它组件类型的可访问性一致，如果组件类型不是引用类型，那么数组类的可访问性默认为public

### 2.2 生成Class对象

在获得类文件的二进制的字节流后，会被转化为方法区的动态存储结构，这个结构是怎么样的并没有强制规定。但是在转化完成后，会在**堆区**实例化一个代表当前类的Class对象。作为方法区存储结构中的数据的访问接口。

**加载阶段和连接阶段是交叉进行的。**

## 3. 验证

验证显而易见就是验证获取的二进制字节流是否安全，符合虚拟机规范。**因为Class不一定是通过编译生成的**，也确实可以直接在二进制层面拼接。**那么在生成Class对象前不是应该先完成验证步骤？**

验证主要验证四个部分：

1. 文件格式的验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 3.1 文件格式验证

文件格式的验证就是验证我们在加载阶段获取到的二进制字节流是否符合**Class文件格式**的规范，只有完成这一步验证，字节流才会转化为方法区的存储结构，并且后续的三个验证步骤是基于方法区的存储结构，而不会直接操作二进制流了。

### 3.2 元数据验证

元数据验证是验证方法区存储的字节码是否《java语言规范》的语法要求。所谓的语义包括是否继承了final修饰的类、是否修改了final修饰的字段等等。即验证是否符合java的语法。

### 3.3 字节码验证

字节码验证主要是验证代码的语义正确性。例如将父类对象赋值给子类引用（语法验证会通过，但可能会产生运行时问题）。如果代码没有通过字节码验证，说明代码肯定有错误，但反之则不一定，即使通过了验证，也不能说代码完全正确，有可能产生间接的语义错误。

但是计算代码是否有语义错误显而易见是一项庞大的工程，放到代码运行之前验证不太好。所以在JDK6之后，java团队将验证语义的操作大部分都转移到了编译期间。编译器会在编译时为代码属性添加`StackMapTable`属性，这一属性描述了代码是否有语义错误。在字节码验证阶段jvm只需要验证该属性是否符合规范。当然，这并不能做到十全十美。

### 3.4 符号引用验证