---
title: 类的加载机制
mathjax: true
data: 2020-11-05 21:16:52
updated:
tags: 类加载
categories: jvm
---

# 1. 类加载的时机

在Java中，只有主动引用才会触发类加载动作。所谓的主动引用指**只**包括以下五种情况（除了下面这五种情况，其余的引用都称为被动引用）：

1. 遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。
3. 当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。
5. 当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

**注意：**
对于静态字段或者静态方法，只会对定义了这些内容的类执行类加载动作。我们通过下面的代码来理解这句话的真正含义：

``` java
public class staticTest {
    public static void main(String[] args) {
       subTest.m1();
    // System.out.println(subTest.a);
    }
}

class subTest extends Test{
    static {
        System.out.println("load subclass subTest");
    }
}
class Test{
    static int a;
    static {
        System.out.println("load class Test");
    }
    public static void m1(){
        System.out.println("method m1");
    }
}

```

执行结果为：

> load class Test
method m1

虽然通过子类名称调用父类的静态方法，但是jvm仍然只会加载真正定义了静态方法`m1`的类`Test`。这是一个特殊情况。

# 2. 类加载的七个步骤

将类的Class文件加载至jvm中一般会经历七个步骤：加载、验证、准备、解析、初始化、使用、卸载。但是注意：**这七个步骤并不是完全串行的**。有可能在一个步骤的执行中开启另外一个步骤，而不是等待当前步骤执行完毕。

并且其中的验证、准备、解析合在一起叫做“连接”。这不就是cpp编译过程的符号链接的步骤嘛，搞的这么花里胡哨的。

并且其中的初始化是指类的初始化，而不是对象的初始化。类的初始化是指：

- 静态字段的初始化
- 静态代码的执行

并且类的初始化只会在类加载的时候执行一次。下面我们就来看看这七个步骤。

## 2.1 加载

这个加载是指整个类加载过程中的第一个步骤，而且是整个类加载过程中我们可以实实在在用代码控制的部分。该步骤分为三小步：

1. 通过类的全限定名获取类的二进制字节流
2. 将二进制字节流表示的静态存储结构转化**方法区**为运行时存储结构
3. 生成Class对象，作为方法区各种类型数据的访问接口

其中通过类的权限名获取类的二进制字节流就是我们能够控制的部分，虚拟机规范只规定了我们要获取字节流，而没有规定从哪里获取字节流。可以从Class文件中获取、静态的jar包中获取、网络中获取，或者动态的在内存中生成，也就是所谓的动态代理技术，这完全都可以自定义实现。**并且获取字节流这个动作就是通过我们自定义的类加载器来实现。**

但是有一个特殊情况，就是数组类的加载不是我们可以控制的，但是数组中的元素类却又是我们可以控制的。因为**数组类的并不是由类加载器加载，而是由jvm在内存中直接构造的。**

---
这里的数组类可以看作数组的wrapper，即数组的包装类，由jvm动态生成，数组类提供了一些数组的属性，并且数组的访问也通过该类实现。

>java访问数组的安全性比c++高很大程度是因为该类包装了数组的访问操作。
---

### 2.1.1 数组类的加载机制

- 如果数组的组件类型(即数组去掉一个维度，例如int[4]\[3],实际的组件类型为int[3],因为二维数组可以看作元素类型是一维数组的一维数组)。那么就递归的采用类加载过程去加载这个组件类型。是类就用类的加载过程，是数组类就用数组类的加载过程。并且该数组会被标识在加载该组件类型的类加载器的类名称空间上，因为这样才能唯一的确定一个类
- 如果数组的组件类型不是引用类型，那么该数组会被标识在启动类加载器的类名称空间上
- 数组类的可访问性和它组件类型的可访问性一致，如果组件类型不是引用类型，那么数组类的可访问性默认为public

### 2.1.2 生成Class对象

在获得类文件的二进制的字节流后，会被转化为方法区的动态存储结构，这个结构是怎么样的并没有强制规定。但是在转化完成后，会在**堆区**实例化一个代表当前类的Class对象。作为方法区存储结构中的数据的访问接口。

**加载阶段和连接阶段是交叉进行的。**

## 2.2 验证

验证显而易见就是验证获取的二进制字节流是否安全，符合虚拟机规范。**因为Class不一定是通过编译生成的**，也确实可以直接在二进制层面拼接。**那么在生成Class对象前不是应该先完成验证步骤？**

验证主要验证四个部分：

1. 文件格式的验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 2.2.1 文件格式验证

文件格式的验证就是验证我们在加载阶段获取到的二进制字节流是否符合**Class文件格式**的规范，只有完成这一步验证，字节流才会转化为方法区的存储结构，并且后续的三个验证步骤是基于方法区的存储结构，而不会直接操作二进制流了。

### 2.2.2 元数据验证

元数据验证是验证方法区存储的字节码是否《java语言规范》的语法要求。所谓的语义包括是否继承了final修饰的类、是否修改了final修饰的字段等等。即验证是否符合java的语法。

### 2.2.3 字节码验证

**字节码验证主要是验证代码的语义正确性。**例如将父类对象赋值给子类引用（语法验证会通过，但可能会产生运行时问题）。如果代码没有通过字节码验证，说明代码肯定有错误，但反之则不一定，即使通过了验证，也不能说代码完全正确，有可能产生间接的语义错误。

但是计算代码是否有语义错误显而易见是一项庞大的工程，放到代码运行之前验证不太好。所以在JDK6之后，java团队将验证语义的操作大部分都转移到了编译期间。编译器会在编译时为代码属性添加`StackMapTable`属性，这一属性描述了代码是否有语义错误。在字节码验证阶段jvm只需要验证该属性是否符合规范。当然，这并不能做到十全十美。

### 2.2.4 符号引用验证

符号引用验证的目的是为了保证**解析阶段**正常进行。会进行权限检查

### 2.2.5 小结

验证阶段可有可无，并不是强制的，只要能够保证代码是正确的，那么也可以关闭大部分类的验证措施来加速类的加载。

## 2.3 准备

准备阶段是为类的静态变量(而不是实例变量，实例变量会在对象实例化时分配空间)分配内存空间，以及赋予静态变量默认的初值，这里的初值指的是int的默认为0、boolean的默认为false之类的默认值。例如:

> public static int value=123;

在准备阶段，value的值为默认值，即为0。在初始化阶段才会被赋值为123。

**无论代码中有没有对静态变量的赋值的操作，都会对变量进行初始化操作，至于赋值的步骤，会在初始化阶段完成!!!**

注意：准备阶段只为静态变量做准备。

## 2.4 解析

解析肯定就是符号的链接过程咯。准备来说就是将常量池中的符号引用替换为直接引用。例如Class文件中的`CONSTANT_Class_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Method_info`等符号引用，存储形式都是常量。

>解析过程是把符号链接到正确的内存地址，符号引用变为直接引用，而不是确定符号，后者是编译期做的事，~~解析这件事已经属于运行期了~~。准确来说，解析并不是运行期，因为解析阶段还没有真正的开始执行字节码，我的理解时**执行字节码才叫做真正的运行期**。

在解析阶段解析符号的过程被称为**静态解析**，当然能够被静态解析的符号类型有限：

- 类或接口
- 字段
- 一部分方法
- 接口方法

关于方法的解析比较复杂，后文单独开一章进行讲解。

### 2.4.1 类或接口的解析

类或接口的解析有一个核心规则：

如果当前代码所处的类为D，如果想要把D中一个从未解析过的符号引用N解析为类或接口C，那么则有：

1. 如果c不是一个数组类型，那么会使用**D的类加载器**加载c，其中会将c的全限定名传递给D的类加载器。如果其中又需要加载其他类，那么重复整个解析程序

2. 如果c是一个数组类型，并且数组元素是对象类型，那么会重复第一步，**并且由虚拟机生成该数组**

3. 如果上面两步没有出现问题，那么会检查符号引用的权限，确认D对C具有访问，否则会抛出异常

### 2.4.2 字段的解析

首先我们需要找到字段所属的类或接口C，然后：

1. 如果在c中找到了简单名称和描述符都与目标相符的字段，那么会返回字段的直接引用

2. 在c实现的接口中，从下往上查找目标

3. 在c继承的父类中，从下往上查找目标

4. 如果成功获得了直接引用，还会检查是否对目标字段具有访问权限

如果在c的父类或接口中实现了相同字段，虽然按照规则可以成功找到目标字段，但是编译器为了安全，还是会选择拒绝编译。

>字段会在解析阶段完全解析好，因为符号引用在编译时期就确定了

### 2.4.3 接口方法的解析

首先在接口方法表中解析出当前方法所属的类或接口c，然后：

1. 如果c是一个类，那么抛出IncompatibleClassChangeError

2. 否则在接口c中查看目标方法，如果成功，则返回直接引用

3. 否则在c继承的接口中查找目标方法，这一步骤有一点值得注意：会一直向上递归查找，直到对java.lang.Object查找完毕，因为接口方法的查找范围**包括Object类中的方法。**

4. 对查找的直接引用进行权限检查在JDK9之后，因为JDK9之后引入了模块化系统。

如果在继承的多个父接口中查找到了多个目标方法，虽然虚拟机规范规定随意返回一个即可。

## 2.5 初始化

这里的初始化是指对类进行初始化，并且这一阶段可以通过程序控制。

初始化阶段就是执行类构造器`<cinit>()`方法的过程。这一方法通过编译器自动生成，生成规则如下：

1. 收集类中所有类变量的赋值动作和静态代码块的语句按**顺序**而合成，如果没有静态变量**赋值**语句和静态代码块，那么并不会生成`<cinit>()`

2. 静态代码块只能访问定义在块之前的静态变量，对于块之后定义的静态变量，静态代码块只能赋值，不能访问

3. 虚拟机会保证父类的类构造器`<cinit>()`一定会在子类的`<cinit>()`执行之前执行，这与实例构造器`<init>()`一样，会保证父类的实例构造器先于子类执行，并且JVM保证在多线程环境下`<cinit>()`只会被执行一次


### 2.5.1 接口的初始化

对于接口来说，并没有强制要求父接口的`<cinit>()`一定要在子接口`<cinit>()`之前执行。只有当父接口中定义的变量被使用时，才会执行父接口的`<cinit>()`方法。并且接口的实现类初始化时也不会执行接口的`<cinit>()`方法。

# 3. 类方法的解析

方法的总体来说可以分为两个部分：

- 能够在解析阶段完成解析的方法
- 只能在运行时完成解析的方法

那么如何区分它们呢？这与具体的方法调用的字节码指令有关，在java中，有五条字节码与方法调用有关：

- invokestatic:调用静态方法
- invokespecial：用于调用特殊的实例方法，包括实例初始化方法（<init>()方法）、私有方法、父类方法（**最近的一个父类**）
- invokevirtual：用于调用对象的实例方法
- invokeinferface：用于调用接口方法
- invokedynamic：用于运行时动态解析出调用点限定符所引用的方法

我们可以根据这五条调用方法的指令来判定当前方法能否在类加载过程中的解析阶段完成符号链接。值得注意的是**前四条的方法调用逻辑**是完全固化在虚拟机内的，而最后一条指令的调用指派完全由程序员指定。

## 3.1 类加载阶段的方法符号解析

只要是通过`invokestatic`、`incokespecial`调用的或者被`final`修饰的方法，就能在类加载阶段中的解析步骤时将符号引用转换为目标方法的直接引用。总计分为五种方法：

- 静态方法
- 对象的构造方法
- 私有方法
- 父类方法
- 被`final`修饰的方法

上述五类方法被称为“非虚方法”，调用的方法的符号引用在编译器就已经完全确定，这类方法的调用称为**解析**。其他的所有方法都为“虚方法”，java中默认方法都是虚方法。

## 3.2 运行时的方法符号解析

除了在3.1小节指出的非虚方法外，其余的方法会在第一次调用时进行链接。这类方法的符号解析有一个特殊的名字，称为**分派**。顾名思义，分派肯定是从多个候选者选择一个。我认为这是与解析最大的不同，因为解析调用的候选方法只有一个。

分派又可分为静态分派和动态分派。

### 3.2.1 静态分派

所谓的静态分派和上述非虚方法的解析并没有太大差别，都是在编译期确定目标方法的符号引用。值得注意的是：在重载环境下，编译器依赖方法参数的静态类型选择合适的版本。这也侧面说明了重载时只有参数不同才算重载。

这类依赖静态类型来决定目标方法版本的操作称为静态解析，因为候选者有多个！**静态解析的结果由编译器决定而不是虚拟机。**

### 3.2.2 动态分派

静态分派是靠编译器实现的，动态分派是靠`invokevirtual`执行实现的，`invokevirtual`的执行步骤如下：

1. 找到操作数栈顶第一个元素指向的对象的实际类型C
2. 在类C中查找是否存在描述符和简单名称都符合预期目标的方法，如果存在，那么结束查找
3. 否则在类C的各个父类中进行查找，直到无法找到抛出异常

这类依赖变量动态类型来决定调用的方法版本称为动态分派。值得注意的是：字段永远不存在多态，只会存在覆盖的概念。查询字段只会在最近的范围内查找。下面的代码很好地解释了动态分派与同名字段覆盖：

``` java
public class FieldHashNoPolymorphic {
    static class Father {
        public int money = 1;
        public Father() {
            money = 2;
            System.out.println(this.money+"---"+this);
            showMeTheMoney();
        }
        public void showMeTheMoney() {
            System.out.println("I am Father, I have $" + money);
        }
    }
    static class Son extends Father {
        public int money = 3;
        public Son() {
            super(this);
            System.out.println(this);
            money = 4;
            showMeTheMoney();
        }
        @Override
        public void showMeTheMoney() {
            System.out.println("I am Son, I have $" + money);
        }
    }
    public static void main(String[] args) {
        Father guy = new Son();
        // 通过静态类型访问到了父类中的money，输出2
        System.out.println("This guy has $" + guy.money);
        // 将静态类型强转成Son，访问的就是子类中的money，输出4
        System.out.println("This guy has $" + ((Son) guy).money);
    }
}
# 输出如下
2---jvm.FieldHashNoPolymorphic$Son@6ed3ef1
I am Son, I have $0
jvm.FieldHashNoPolymorphic$Son@6ed3ef1
I am Son, I have $4
This guy has $2
This guy has $4

```

在第一次执行中，为什么会调用`Son`类的`showTheMoney()`?因为在调用方法时，会将方法接收者（也就是caller）的引用传递进去，调用父类构造函数的代码是`super(this)`，这里的`this`代表`Son`类的对象。所以在执行下面代码时：

``` java
public Father(this) {
    this.money = 2;
    this.showMeTheMoney();
}
```

虽然这里的`this`指向的是子类`Son`对象，但是我们想想，`Son`对象肯定会包含了父类`Father`的数据啊，所以这两个`this`显示地是同一个地址没毛病。

但是`sout(this.money)==2`就说明这里使用的`money`属性是父类的，因为代码执行处离父类`Father`最近。而显示的`I am Son, I have $0`就说明此时使用的是子类`Son`的`money`属性，因为此时代码执行处处离`Son`最近。值为0是因为此时子类`Son`的`money`属性还没有初始化，因为父类的构造函数还未执行完毕。

虽然在Son类型的对象中，内存中会存在两个`money`,但是Son对象只会使用离他最近的一个，也就是自身类中的`money`属性，子类的属性会隐藏父类的同名属性。

### 3.2.3 单分派与多分派

决定单分派与多分派的标准是使用的宗量数量。宗量分为两大类：方法的接受者（caller）与方法的参数。采用《深入理解java虚拟机》中的例子作为解释：

``` java
public class Dispatch {
    static class QQ{}
    static class _360{}

    public static class Father{
    public void hardChoice(QQ arg)
    {
        System.out.println("father choose qq");
    }
    public void hardChoice(_360 arg)
    {
        System.out.println("father choose 360");
    }
    }

    public static class Son extends Father{
    public void hardChoice(QQ arg)
    {
        System.out.println("son choose qq");
    }
    public void hardChoice(_360 arg)
    {
        System.out.println("son chooes 360");
    }
    }

    public static void main(String[] args) {
    Father father = new Father();
    Father son = new Son();

    father.hardChoice(new _360());//father choose 360
    son.hardChoice(new QQ());//son choose qq
    }
}
```

对于`fahter.hardChoice(new _360())`,在编译时期编译器确定调用符号时，可以看出候选者非常多（候选者有哪些，需要列出来）。那么在调用`father.hardChoice`时发现方法的接收者的静态类型这是`Father`,这就决定了在`Father`类中选择。那么接着查看调用方法的参数，发现实参的静态类型为`360`,那么通过方法调用者和函数实参这两个标准在编译器确定了符号调用，这就代表使用了两个宗量。同理编译`son.hardChoice(new QQ())`时也会使用两个宗量确定符号引用。

上述确定的两个符号引用会使用`invokevirtual`调用。那么在运行时,因为已经在编译器确定了方法签名，但是候选者仍然有两个：

- Father::hardChoice(_360 arg)
- Son::hardChoice(_360 arg)

因为上述的两个函数调用实际会使用`invokeVirtual`执行，所以在运行时虚拟机会从上述的两个候选者中选择一个。以`father.hardChoice(new _360())`为例，方法接收者`father`的实际类型为`Son`，所以虚拟机会选择`Son`类中的方法。可以看出在抉择过程中只用了“方法调用者”这一个参考因素。

所以到目前为止，**java是一个静态多分派、动态单分派的语言**。那么时候才会进入分派的阶段，也就是使用`virtualinvoke`指定？

我认为答案是调用非虚方法时，会进入分派阶段。

---

**Extension: invokevirtual的执行过程**

1. `invokevirtual`首先会找到操作数栈的栈顶第一个元素所指向的对象的实际类型，记为C；
2. 在C自身中进行查找符号和描述相符的方法，如果找到，则需要检查权限
3. 如果在C自身中未找到，那么会按照继承关系**自下而上**在C的父类中进行查找，如果找到则需要进行权限检查
4. 如果都为找到，则会抛出`AbstractMethodError`异常

---

### 3.2.4 分派的具体实现

在每次调用时才去执行分派效率必定低下，所以jvm选择以虚表(virtual method table)的形式实现分派的过程。虚表和cpp中的虚表概念差不多。这个虚表建立在方法区。对于子类来说，如果没有重写父类的方法，那么子类的虚方法表中，没有被重写的方法的指针和父类同一方法的指针指向同一个函数。

> 虚表会在类加载阶段完成初始化，在完成连接阶段中的初始化过程后，会完成该类的虚表初始化


# 4. 小测试

根据类加载的规则，下面的代码输出到底是多少？

``` java
class SingleTon {
    private static SingleTon singleTon = new SingleTon();
    public static int count1;
    public static int count2 = 0;
 
    private SingleTon() {
        count1++;
        count2++;
    }
 
    public static SingleTon getInstance() {
        return singleTon;
    }
}
 
public class Test {
    public static void main(String[] args) {
        SingleTon singleTon = SingleTon.getInstance();
        System.out.println("count1=" + singleTon.count1);
        System.out.println("count2=" + singleTon.count2);
    }
}
```
一个经常出现的错误答案是：
>count1=1;
count2=1;

但是正确的执行结果为：

>count1=1;
count2=0;

为什么呢？因为类加载过程中准备阶段是在初始化阶段之前的，虽然在上面的代码中有`count2=0`，但是准备阶段不关心这个。准备阶段完成后：

> count1=0;
count2=0;

最后在初始化过程中，编译器生成的`<cinit>`方法是按照代码书写顺序生成的，例如这个例子中生成的是：

``` java
cinit(){
    private static SingleTon singleTon = new SingleTon();
    public static int count1;
    public static int count2 = 0;
}
```

虽然在执行`SingleTon`的构造方法时，会执行`count2=1`的操作，但是注意，`<cinit>`方法还没有执行完成呢。在`<cinit>`中最后还是会执行`count2=0`的操作。

所以最终的答案是：

> count1=1;
count2=0;