---
title: java的内存布局
mathjax: true
date: 2020-07-21 23:32:14
updated:
tags: 内存布局
categories: jvm
---

## 前言

众所周知,java虚拟机的内存布局和传统的内存布局都差不多,都分为栈、堆啥的。准确的来说，jvm的内存分为以下几个部分:

- 程序计数器(就是eip)
- 堆
- 方法区
- 本地方法栈
- 虚拟机栈

其中堆和方法区是所有线程锁共享的,而程序计数器、栈肯定都是线程私有的,因为这与程序的正常运行息息相关。

上述的五个区域都可能产生内存溢出,有的还可能产生内存泄漏(虽然内存由jvm管理,但是并不能保证内存不会泄露奥)。下面我将一一介绍上述四个区域(不包括程序计数器)产生内存溢出的一般情况,当然大部分内容还是来自<<深入理解JVM>>一书,我在这里仅仅做个概括加上自己一点的感想。

## 0x1 虚拟机栈

虚拟机栈跟传统汇编里的栈感觉差不多,只不过这里用所谓的局部变量槽来保存(Slot)。当然栈就是用来存储局部变量和返回地址的，内容肯定和传统栈一样。当然本地方法栈和虚拟机栈在性质上就是一类东西,**仅仅是用途不同而已**。所以就不单独分开说本地方法栈了。

Tips:
> 当进入一个方法时,这个方法需要多少个局部变量槽是确定的,局部变量所需的内存在编译时期分配完成,而具体内存是多少个byte是不确定的,因为局部变量槽的实现方式不在JVM规范中。由虚拟机厂商所决定。

上面这个我也是才注意的,不像传统栈可以不停的push,使用的大小完全无法确定。

进入正题,虚拟机栈可能会发生两种内存错误:

- StackOverFlow
- OutOfMemeory

StackOverFlow要么是死递归造成的栈空间不够,要么是局部变量太多。感觉后者不太可能发生,因为需要的局部变量太多儿。所以出现StackOverFlow的第一直觉就是死递归。

第二种出现于允许栈可扩展的虚拟机中。虚拟机之王HotSpot是不支持虚拟机栈扩展的。但是仍然可能出现OOM,当线程申请栈空间失败时。反之申请成功就永远不会出现OOM。

## 0x2 堆

堆是所有线程共享的内存区域,堆中能出现的内存错误当然是OOM辣。在Java中,几乎所有的对象实例都在堆中分配(具体解释来自深入理解JVM:page45)。

堆的可以被实现为固定的或者可扩展的。hotSpot中堆属于可扩展的。堆的大小可以通过参数`-Xms`(初始堆的大小)和`-Xmx`(堆的最大值)来控制。

当在堆中无法完成对象的分配时,在堆上就会出现OOM。

### 0x2-1 方法区

方法区跟堆一样也是属于所有线程共享的内存区域。其中主要存储由虚拟机加载的类型信息、常量、静态变量、JIT编译后的缓存数据等等。

在JDK8以前,HotSopt采用了永久代的方法实现了方法区,从而能够像管理堆一样管理方法区。**但是这是一个陋习**。永久代有上限,这就导致在加载过多类后会出现内存溢出。

所以在JDK7中,oracle已经将方法区中的常量池、静态变量移出了永久代。在JDK8中,在方法区中彻底废除了永久代,通过在本地内存中实现元空间(与J9类似)保存剩余的信息,大部分都是类型信息。

虚拟机规范对方法区的要求是非常宽松的,比如方法区可以**不执行内存回收**,当然在方法区执行内存回收也是比较麻烦的。

当在方法区中无法申请到满足要求的内存时,就会出现OOM错误。

### 0x2-2 运行时常量池

运行时常量池本来是属于方法区的东西(注意oralce在JDK7是把常量池移出了永久代,而不是移出了方法区)。在Class文件中有一项信息为常量表,存储的是编译时期的各种常量与符号引用。这部分内容将在类加载完成后存放至方法区的运行时常量池。

当然常量池的内容不一定得是编译时的常量，也可以在运行时将新常量加入到池中。所以说运行时常量池与Class文件的常量池相比,前者具有动态性。

运行时常量池既然是方法区的东西,自然也会受到方法区的限制,当无法申请到足够多的内存时,就会出现OOM。

## 0x3 直接内存

直接内存并不是虚拟机规范中定义的内存区域,但是逐渐变得很重要。

在JDK1.4中,java引入了NIO。注意IO操作可以是要频繁跟本地堆的内容进行交互的。所以在NIO中：

> 引入了一种基于管道和缓冲区的IO方式,可以直接使用native函数库分配native堆,然后通过一个存储在java堆中的DirectByteBuffer对象作为native堆的引用来操作native堆

上述这种操作就避免了在java堆中和native中频繁的复制数据。

native堆的分配大小一般都会忽略,导致各个内存区域的大小总和超过了本机主机内存,从而出现OOM。

## 参考文献

1. [Understanding Java Memory Model](https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973)