---
title: Java中的GC
mathjax: true
date: 2021-03-21 16:21:08
updated:
tags:
- garbage collection
categories:
- java
---

Java中的自动垃圾回收是其一大优点。本文将从以下三个方面简介相关知识：

1. 如何定义垃圾
2. 垃圾回收的时机
3. 垃圾回收的策略
4. 具体的垃圾回收器

在介绍相关的知识前，我们需要知道一个词：`stop-the-world`，这个词专门为GC而生，因为Java会在进行垃圾回收的时候除了GC线程外，会暂停所有工作线程，也就是所谓的“停止世界运转”。那么GC优化时，我们的目标可能就是减少GC时`stop-the-world`的时间（这句话网上抄的，当然大部分内容都是）。

## 1. 如何定义垃圾

在Java中，定义一个对象为垃圾的策略分为两种：

1. 引用计数法
2. 可达性算法

所谓的**引用计数法**，也就是说：对于一个对象A，如果它的被引用次数为0，就说明没有别的对象在使用A，那么A自然而然地称为垃圾。但是这种会存在循环引用的问题。我们看看下面的代码：

``` java
class A{
    private B b;
    public void setB(B b){
        this.b=b;
    }
    ...
}
class B{
    private A a;
    public void setA(A a){
        this.a=a;
    }
    ...
}

public static void main(String[] args){
    A a=new A();
    B b=new B();
    a.setB(b);
    b.setA(a);
    a=null;
    b=null;
}
```

上面的代码中，在将a、b设置为null后，看似会被回收，但是实例a中仍然持有实例b的引用，实例b同理。这样实例a和b的引用计数各位1。如果以后不再使用这两个实例，那么就会造成内存泄漏。

可达性算法就是为了解决上述循环引用的问题。按照我的理解，所谓的可达性分析，是指一个实例的调用链，而调用链又是通过一个名叫`GCRoot`的数据结构维持的。所谓的`GCRoot`可以由以下四种中任意一个组成：

1. 方法区中静态属性引用的对象
2. 方法区中常量引用的对象
3. 虚拟机栈中引用的对象
4. 本地native栈中引用的对象

## 2. 垃圾回收的时机

Java把它的内存区域在逻辑上划分为三类：新生代、老年代、永久代。Java对这三类采用了不同的垃圾回收时机。

### 2.1 新生代

所谓的新生代就是Java在构造实例的时候会使用这块内存，大对象（需要使用连续内存的对象）会直接放在老年代。

Java又把新生代划分为三个区域：Eden、survivor0和survivor1，每次只会使用Eden区和某一个survivor。假设在初始时，我们使用的Eden区和survivor0区，那么当这两个子区满了之后，会将它们中存活的对象复制到survivor1，这个过程叫做**MinorGC**，也就是次要的垃圾回收，当然MinorGC并不一定要Eden区满了才执行，有可能会经常执行（存疑）。此后survivor1和survivor0的角色交换。JVM使用Eden和survivor1。满了之后重复上述过程。

**特别的，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。**

**新生代的回收时机就是Eden和某一个survivor内存用尽。**

### 2.2 老年代

至于老年代，存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。

如果老年代也满了，就会触发一次**FullGC**，也就是**新生代、老年代都进行回收**。当然FullGC执行的频率比较低。导致FullGC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。

### 2.3 永久代

永久代主要用于存放静态文件，如Java类、方法等。

## 3. 垃圾回收的策略

Java的垃圾回收策略主要有三种：

1. 标记清除
2. 复制交换
3. 标记整理

### 3.1 标记清除算法

标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收，

标记-清除算法的主要不足有两个：

1. **效率问题**：标记和清除两个过程的效率都不高;
2. **空间问题**：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 3.2 复制算法

所谓的复制算法就是将堆区一分为二，分为A和B。每次只使用一个，当A满了之后，将A中存活的对象复制到B中。这种算法非常适用于存活率低的对象。因为需要复制的内容不会很多，并且复制时只需要调整指针，也不需要考虑内存碎片的问题，并且这种策略已经用于商业虚拟机中的新生代回收算法，**因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。**

### 3.3 标记整理算法

标记整理算法与标记清除算法类似，唯一的不同时，前者会在清除完毕后，有一个整理内存碎片的操作。这样就解决了标记清除算法中的空间问题。

## 4. 垃圾回收器

可以按照垃圾回收器作用的内存区域分类：

作用于新生代的包括：

- ParNew收集器 (复制算法)，**并行**
- Parallel Scavenge收集器，**并行**，追求高吞吐量

作用于老年代的包括：

- CMS，**并行**，使用标记清除策略，追求最短GC回收停顿时间。
- Parallel Old收集器，**并行**，使用标记-整理策略，追求高吞吐量

作用于两者的包括：

- G1收集器，**并行**，使用标记整理策略


## 参考文章

1. [java面试官最爱问的垃圾回收机制，这位阿里P7大佬分析的属实到位](https://segmentfault.com/a/1190000023637649)