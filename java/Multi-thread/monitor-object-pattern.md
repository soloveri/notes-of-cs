---
title: monitor object模式
mathjax: true
data: 2020-12-01 19:54:01
tags: 
- synchronized
categories:
- 多线程基础
---

## 前言

为了学习`synchronized`的实现原理，进而了解到`monior object`模式。在java中`synchronized`辅助实现了该模式。

## 1.monitor object的起源与定义

起源摘自[探索 Java 同步机制](https://developer.ibm.com/zh/articles/j-lo-synchronized/)：

> 我们在开发并发的应用时，经常需要设计这样的对象，该对象的方法会在多线程的环境下被调用，而这些方法的执行都会改变该对象本身的状态。为了防止竞争条件 (race condition) 的出现，对于这类对象的设计，需要考虑解决以下问题：
在任一时间内，只有唯一的公共的成员方法，被唯一的线程所执行。
对于对象的调用者来说，如果总是需要在调用方法之前进行拿锁，而在调用方法之后进行放锁，这将会使并发应用编程变得更加困难。合理的设计是，该对象本身确保任何针对它的方法请求的同步被透明的进行，而不需要调用者的介入。
如果一个对象的方法执行过程中，由于某些条件不能满足而阻塞，应该允许其它的客户端线程的方法调用可以访问该对象。

**定义：**
>我们使用 Monitor Object 设计模式来解决这类问题：**将被客户线程并发访问的对象定义为一个 monitor 对象**。客户线程仅仅通过 monitor 对象的同步方法才能使用 monitor 对象定义的服务。为了防止陷入竞争条件，在任一时刻只能有一个同步方法被执行。每一个 monitor 对象包含一个 monitor 锁，被同步方法用于串行访问对象的行为和状态。此外，同步方法可以根据一个或多个与 monitor 对象相关的 monitor conditions 来决定在何种情况下挂起或恢复他们的执行。

注意，上述定义的`monitor object`是包含了同步方法的对象，而不是常规使用`synchronized`时后面括号中的对象。


监视者对象
同步方法
监视锁
监视条件



